# 동기 vs 비동기 작업의 이해

## 동기 작업 (Synchronous I/O)
- 호출자(클라이언트)가 요청을 보낸 뒤 응답을 받을 때까지 작업이 차단(blocked)됨.
- 호출자와 수신자(서버)가 완전히 동기화되어 서로 같은 시간에 작업을 수행함.
- **특징**:
  - 오래된 방식으로, 간단하지만 효율성이 떨어짐.
  - 차단된 작업은 컨텍스트 스위칭을 통해 다른 프로세스가 실행됨.
  - 작업 완료 후에야 다음 작업을 진행할 수 있음.
  - 읽기나 쓰기 작업이 끝나야 호출자는 계속 작업을 수행할 수 있음.

### 예시
- **전화 통화**: 통화 중에는 다른 일을 할 수 없음.

---

## 비동기 작업 (Asynchronous I/O)
- 호출자(클라이언트)가 요청을 보낸 후 응답을 기다리지 않고 다른 작업을 계속 수행 가능.
- 수신자가 작업을 완료하면 호출자에게 알림(콜백)으로 응답을 전달.
- 호출자와 수신자가 반드시 동시에 작업할 필요가 없음.
- **특징**:
  - 응답을 받기 위해 `epoll`(Linux), `IOCP`(Windows), 또는 `io_uring`(Linux)와 같은 비동기 처리 메커니즘 사용.
  - 보조 스레드가 작업을 처리하며, 메인 스레드는 차단되지 않음.
  - 메인 스레드가 유지되므로 다른 작업과의 병렬 처리가 가능.

### 예시
- **이메일**: 이메일을 보낸 후 답변을 기다리지 않고 다른 작업을 수행 가능.

---

## 요청과 응답의 동작 방식
### 동기 작업
- 클라이언트는 서버의 응답을 기다리며 차단됨.
- **예**: HTTP 요청에서 긴 대기 시간 동안 클라이언트는 다른 작업을 할 수 없음.

### 비동기 작업
- 클라이언트는 요청을 보낸 후 비동기적으로 처리되며, 응답이 준비되면 콜백으로 알림을 받음.
- **예**: 푸시 알림, 비동기 API 호출.

---

## 비동기 백엔드 처리
- 시간이 많이 걸리는 요청은 비동기적으로 처리하여 서버가 차단되지 않도록 함.

### 방법
1. **큐 사용**:
   - 요청을 작업 큐에 넣고 작업 ID를 클라이언트에 반환.
   - 작업 큐에서 요청을 처리한 뒤, 작업 완료 여부를 클라이언트가 확인.
2. **작업 상태 확인**:
   - **폴링**:
     - 클라이언트가 서버에 주기적으로 작업 상태를 요청.
   - **푸시 기반(pub/sub)**:
     - 작업이 완료되면 서버가 클라이언트에 알림.

### 예시
- **PostgreSQL의 비동기 커밋**:
  - 트랜잭션 데이터는 메모리(WAL)에 저장하고, 디스크에 기록하기 전에 성공을 반환.
  - 이를 통해 클라이언트의 대기 시간을 줄임.

---

## 비동기 복제
- 데이터베이스의 비동기 복제는 주(primary) DB와 보조(secondary) DB 간에 복제 작업을 분리하여 처리.

### 특징
- 주 DB의 트랜잭션은 바로 디스크에 커밋되지 않고, 보조 DB로 복제 작업을 전달.
- 복제 작업 완료 여부와 관계없이 트랜잭션은 성공으로 처리.

### 비동기 복제의 장점
- 데이터 일관성을 완벽히 보장하지 않지만 성능 최적화에 유리.

---

## 운영체제와 파일 시스템에서의 비동기 처리
### 비동기 쓰기(Asynchronous Write)
- 데이터는 즉시 디스크에 기록되지 않고 OS 파일 시스템 캐시에 저장.
- 캐시 데이터를 일정 시점에 플러시하여 디스크에 기록.

#### 장점
- 여러 쓰기 작업을 묶어 일괄 처리하여 디스크 성능 최적화.

#### 단점
- 플러시 이전에 시스템이 종료되면 데이터 손실 가능.

---

## 비동기적 처리의 장점
1. **병렬성 증가**: 시스템의 리소스를 효율적으로 활용.
2. **성능 최적화**: 긴 작업 시간을 비동기적으로 처리하여 응답 지연 감소.
3. **유연성**: 다양한 비동기 메커니즘(epoll, io_uring 등)을 통해 요구사항에 맞는 설계 가능.

---

## 비동기적 처리의 단점
1. **복잡성 증가**: 동기 작업에 비해 코드 구조가 복잡.
2. **디버깅 어려움**: 비동기 작업 간의 상호작용을 추적하기 어렵기 때문.
