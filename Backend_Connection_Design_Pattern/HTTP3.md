## 📘 HTTP/3와 QUIC: 왜 필요했고, 어떻게 발전했는가

### 1. HTTP/1.1의 한계
- 브라우저는 각 요청마다 TCP 연결을 새로 열어야 했고, 이를 줄이기 위해 커넥션을 재사용해도 **동시에 여러 요청을 효율적으로 처리하지 못함**.
- 파이프라이닝이 있었지만, **헤드 오브 라인 블로킹 (Head-of-Line Blocking)** 문제가 발생했음.
- 하나의 요청이 지연되면 그 뒤의 요청들도 모두 지연됨.

### 2. HTTP/2의 등장과 혁신
- 하나의 TCP 연결 위에서 **여러 스트림을 다중화(Multiplexing)** 하여 동시에 여러 요청을 처리할 수 있게 함.
- 각 요청을 스트림으로 구분하고, 이를 프레임 단위로 나누어 처리.

#### ⚠️ 하지만 HTTP/2에도 한계가 있었다
- **TCP의 특성상 순서를 보장해야 하므로**, 한 패킷이 손실되면 모든 패킷이 기다려야 함 → 다시 **헤드 오브 라인 블로킹 발생**.
- 이 문제는 스트림 간에 독립적이지 못한 TCP의 구조에서 비롯됨.

### 3. 해결책: 전송 계층까지 새로 만든다
- HTTP/2의 구조는 마음에 들지만 TCP의 한계 때문에 **전송 계층을 바꾸기로 결정**.
- 그래서 나온 것이 **QUIC**.

---

## 🚀 QUIC: 새로운 전송 계층

### QUIC이란?
- **UDP를 기반으로 동작**하는 새로운 전송 프로토콜.
- TCP를 완전히 대체하는 것을 목표로 설계됨.
- TLS(보안), 흐름 제어, 혼잡 제어까지 **모두 자체적으로 구현**.

### QUIC의 특징
- **UDP 기반**이므로 손실된 패킷만 재전송 가능 → 헤드 오브 라인 블로킹 해소.
- 각 스트림은 **독립적인 흐름 제어**가 적용됨.
- **연결 ID** 개념을 도입해 IP가 바뀌어도 연결 유지 가능 (연결 마이그레이션).
- **1-RTT 핸드셰이크**를 통해 연결과 보안을 한 번에 설정.
- 모든 패킷에 **스트림 ID와 연결 ID가 포함**되어, 여러 스트림을 안전하게 동시에 처리 가능.

---

## 🌐 HTTP/3는 QUIC 위에서 동작한다

### HTTP/3 = HTTP/2 구조 + QUIC 전송 계층
- HTTP/2의 **스트리밍, 멀티플렉싱 구조는 유지**.
- 하지만 전송 계층은 QUIC으로 변경하여 TCP의 한계를 극복.

### 압축 알고리즘의 변화
- HTTP/2는 **Hpack** 사용 → 순서에 의존한 압축 방식.
- QUIC은 순서를 보장하지 않으므로, **Qpack**이라는 새 압축 방식을 도입.
  - Qpack은 **헤더 압축을 스트림 독립적으로 수행** 가능하게 만듦.
  - 이를 통해 보안 문제(Hpack 기반 BREACH 등)도 일부 해결.

---

## 🔍 QUIC과 HTTP/3의 장단점

### 장점
- 스트림 간 완전한 독립성 → 헤드 오브 라인 블로킹 제거.
- 0-RTT/1-RTT로 빠른 연결 설정.
- 보안이 내장됨 (기본적으로 TLS 1.3 사용).
- IP 변경에도 연결 유지 가능 (모바일 환경에 유리).
- 각 스트림 별로 혼잡 제어 가능.

### 단점
- 구현 복잡도 증가 → CPU 사용량 증가.
- 아직 일부 네트워크 환경(프록시, 방화벽 등)에서 **UDP 차단 문제** 발생.
- IP 단편화, MTU 관련 문제 → 전송 효율 저하 가능성.
- QUIC은 아직 성숙 과정에 있음.

---

## 🧠 요약

| 버전 | 전송 계층 | 멀티플렉싱 | 보안 | 문제 |
|------|------------|-------------|--------|----------------|
| HTTP/1.1 | TCP | 없음 | TLS 추가 필요 | 커넥션 병목, HOL 블로킹 |
| HTTP/2 | TCP | 있음 | TLS 필요 | TCP 기반 HOL 블로킹 여전 |
| HTTP/3 | **QUIC (UDP 기반)** | 있음 | TLS 1.3 내장 | 일부 환경에서 UDP 차단 |

---